import pandas as pd
import time
from okx import MarketData

# ==================== æ•°æ®è·å–ç±» ====================
class OKXDataFetcher:
    def __init__(self, instId="BTC-USDT"):
        self.instId = instId
        self.df = None
        self._initialize_api()

    def _initialize_api(self):
        """å³ä½¿å…¬å…±APIä¹Ÿéœ€è¦åŸºç¡€é…ç½®"""
        self.market = MarketData.MarketAPI(
            api_key="",
            api_secret_key="",
            passphrase="",
            flag="0"  # 0: å®ç›˜ 1: æ¨¡æ‹Ÿç›˜
        )

    def fetch_1m_data(self, days=1):
        """
        ä»å½“å‰æ—¶åˆ»å¾€å‰æ¨ days å¤©(1å¤©=1440æ¡ 1m Kçº¿)ï¼Œ
        ä½¿ç”¨ 'after' å‚æ•°åˆ†é¡µè·å–æ›´æ—©æ•°æ®ã€‚OKX å…¬å…±æ¥å£ä¸€èˆ¬
        åªèƒ½æä¾›è¾ƒè¿‘çš„ 1~2 å¤© 1m æ•°æ®ï¼Œè¶…è¿‡å¯èƒ½æ‹¿ä¸åˆ°ã€‚
        """
        total_limit = 1440 * days
        all_data = []
        after = None
        retry = 0
        max_retries = 3

        print(f"â–¶ï¸ å¼€å§‹è·å– {self.instId} {days}å¤©æ•°æ®...")

        while len(all_data) < total_limit and retry < max_retries:
            try:
                params = {
                    "instId": self.instId,
                    "bar": "1m",
                    # æ¯æ¬¡è¯·æ±‚æœ€å¤š300æ¡
                    "limit": min(300, total_limit - len(all_data))
                }
                if after is not None:
                    params["after"] = str(after)

                resp = self.market.get_candlesticks(**params)

                if resp.get("code") != "0":
                    print(f"âš ï¸ APIé”™è¯¯: {resp.get('msg')}")
                    retry += 1
                    time.sleep(1)
                    continue

                batch = resp.get("data", [])
                if not batch:
                    print("âœ… å·²è·å–å…¨éƒ¨å¯ç”¨æ•°æ®")
                    break

                all_data.extend(batch)
                oldest = batch[-1]
                oldest_ts = int(oldest[0])
                after = oldest_ts - 1

                print(
                    f"â–å·²è·å– {len(batch):>3} æ¡ï¼Œ"
                    f"ç´¯è®¡ {len(all_data):>4}/{total_limit}",
                    end="\r"
                )
                time.sleep(0.15)
                retry = 0

            except Exception as e:
                print(f"ğŸ”´ è¯·æ±‚å¼‚å¸¸: {str(e)}")
                retry += 1
                time.sleep(2 ** retry)

        # æ•´ç†æˆ DataFrame
        if all_data:
            columns = [
                "timestamp", "open", "high", "low", "close",
                "vol", "volCcy", "volCcyQuote", "confirm"
            ]

            full_df = pd.DataFrame(all_data, columns=columns)
            self.df = full_df[["timestamp", "open", "high", "low", "close", "vol"]].copy()

            numeric_cols = ["open", "high", "low", "close", "vol"]
            self.df[numeric_cols] = self.df[numeric_cols].apply(pd.to_numeric, errors="coerce")

            self.df["timestamp"] = pd.to_datetime(
                pd.to_numeric(self.df["timestamp"]),
                unit="ms",
                utc=True
            ).dt.tz_convert(None)

            self.df = self.df.drop_duplicates(subset=["timestamp"])
            self.df = self.df.sort_values("timestamp").reset_index(drop=True)

            print(f"\nâœ… æœ€ç»ˆè·å– {len(self.df)} æ¡æœ‰æ•ˆæ•°æ®")
            if not self.df.empty:
                print(f"â° æ—¶é—´èŒƒå›´: {self.df.timestamp.iloc[0]} è‡³ {self.df.timestamp.iloc[-1]}")
        else:
            print("âŒ æœªè·å–åˆ°ä»»ä½•æœ‰æ•ˆæ•°æ®")

    def get_cleaned_data(self):
        """è·å–å¤„ç†åçš„å¹²å‡€æ•°æ®"""
        return self.df.copy() if self.df is not None else None


# ==================== ç­–ç•¥æ‰§è¡Œç±» ====================
class VolatilityMeanStrategy:
    def __init__(
        self,
        data_df,
        initial_capital=10000.0,
        params=None
    ):
        # é»˜è®¤å‚æ•°
        default_params = {
            "volatility_window": 5,       # æ³¢åŠ¨ç‡è®¡ç®—çª—å£
            "volatility_threshold": 0.005,# æ³¢åŠ¨ç‡é˜ˆå€¼(å¦‚0.5%)
            "ma_window": 5,              # å‡çº¿è®¡ç®—çª—å£
            "take_profit_long": 0.003,   # å¤šå¤´æ­¢ç›ˆ(0.3%)
            "stop_loss_long": 0.005,     # å¤šå¤´æ­¢æŸ(0.5%)
            "take_profit_short": 0.003,  # ç©ºå¤´æ­¢ç›ˆ(0.3%)
            "stop_loss_short": 0.005,    # ç©ºå¤´æ­¢æŸ(0.5%)
            "max_trades": 10,            # æœ€å¤§æŒä»“æ•°é‡
            "max_drawdown": -0.05,       # æœ€å¤§å›æ’¤(-5%)
            "risk_per_trade": 0.01       # å•ç¬”é£é™©æ¯”ä¾‹(1%)
        }

        if params:
            default_params.update(params)
        self.params = default_params
        self.df = data_df.copy()
        self.signals = None
        self.initial_capital = initial_capital

    def generate_signals(self):
        """ç”Ÿæˆäº¤æ˜“ä¿¡å·"""
        df = self.df
        p = self.params

        # è®¡ç®—æ³¢åŠ¨ç‡
        df['window_high'] = df['high'].rolling(window=p['volatility_window']).max()
        df['window_low'] = df['low'].rolling(window=p['volatility_window']).min()
        df['window_open'] = df['open'].shift(p['volatility_window'] - 1)

        df['volatility'] = (df['window_high'] - df['window_low']) / df['window_open']

        # è®¡ç®—ç§»åŠ¨å¹³å‡
        df['ma'] = df['close'].rolling(window=p['ma_window']).mean()

        # ç”Ÿæˆåˆæ­¥ä¿¡å·
        df['raw_buy'] = (
            (df['volatility'] >= p['volatility_threshold']) &
            (df['close'] < df['ma'])
        )
        df['raw_sell'] = (
            (df['volatility'] >= p['volatility_threshold']) &
            (df['close'] > df['ma'])
        )

        # å»é™¤è¿ç»­ä¿¡å·
        df['buy'] = df['raw_buy'] & ~df['raw_buy'].shift(1).fillna(False)
        df['sell'] = df['raw_sell'] & ~df['raw_sell'].shift(1).fillna(False)

        self.signals = df[[
            'timestamp', 'open', 'high', 'low', 'close',
            'volatility', 'ma', 'buy', 'sell'
        ]].copy()

    def run_backtest(self):
        """æ‰§è¡Œå›æµ‹å¹¶æ‰“å°ç»Ÿè®¡ä¿¡æ¯"""
        if self.signals is None:
            print("âŒ è¯·å…ˆè°ƒç”¨ generate_signals()")
            return None

        import pandas as pd

        equity = self.initial_capital
        peak_equity = equity
        trades = []
        p = self.params

        for idx, row in self.signals.iterrows():
            # 1) æ£€æŸ¥å›æ’¤
            current_drawdown = (equity - peak_equity) / peak_equity
            if current_drawdown < p['max_drawdown']:
                print(f"âš ï¸ è§¦å‘æœ€å¤§å›æ’¤ {current_drawdown:.2%}ï¼Œåœæ­¢äº¤æ˜“")
                break

            # 2) åˆ·æ–°å³°å€¼
            if equity > peak_equity:
                peak_equity = equity

            # 3) å¼€ä»“é€»è¾‘
            open_trades = [t for t in trades if t['exit_time'] is None]
            if len(open_trades) < p['max_trades']:
                if row['buy']:
                    entry_price = row['close']
                    tp_price = entry_price * (1 + p['take_profit_long'])
                    sl_price = entry_price * (1 - p['stop_loss_long'])

                    risk_amount = equity * p['risk_per_trade']
                    price_range = entry_price - sl_price
                    position_size = risk_amount / price_range if price_range != 0 else 0

                    trades.append({
                        'type': 'long',
                        'entry_time': row['timestamp'],
                        'entry_price': entry_price,
                        'take_profit': tp_price,
                        'stop_loss': sl_price,
                        'size': position_size,
                        'exit_time': None,
                        'exit_price': None,
                        'profit': None
                    })

                elif row['sell']:
                    entry_price = row['close']
                    tp_price = entry_price * (1 - p['take_profit_short'])
                    sl_price = entry_price * (1 + p['stop_loss_short'])

                    risk_amount = equity * p['risk_per_trade']
                    price_range = sl_price - entry_price
                    position_size = risk_amount / price_range if price_range != 0 else 0

                    trades.append({
                        'type': 'short',
                        'entry_time': row['timestamp'],
                        'entry_price': entry_price,
                        'take_profit': tp_price,
                        'stop_loss': sl_price,
                        'size': position_size,
                        'exit_time': None,
                        'exit_price': None,
                        'profit': None
                    })

            # 4) å¹³ä»“é€»è¾‘
            for trade in trades:
                if trade['exit_time'] is None:
                    current_high = row['high']
                    current_low = row['low']

                    if trade['type'] == 'long':
                        if current_high >= trade['take_profit']:
                            exit_price = trade['take_profit']
                        elif current_low <= trade['stop_loss']:
                            exit_price = trade['stop_loss']
                        else:
                            continue

                        profit = (exit_price - trade['entry_price']) * trade['size']
                        equity += profit

                    elif trade['type'] == 'short':
                        if current_low <= trade['take_profit']:
                            exit_price = trade['take_profit']
                        elif current_high >= trade['stop_loss']:
                            exit_price = trade['stop_loss']
                        else:
                            continue

                        profit = (trade['entry_price'] - exit_price) * trade['size']
                        equity += profit

                    trade.update({
                        'exit_time': row['timestamp'],
                        'exit_price': exit_price,
                        'profit': profit
                    })

        # ========== å›æµ‹æŠ¥å‘Š: äº¤æ˜“æ˜ç»†ä¸ç»Ÿè®¡ ==========
        report = pd.DataFrame(trades)
        if not report.empty:
            closed_trades = report.dropna(subset=["exit_time"])  # å·²å¹³ä»“çš„äº¤æ˜“
            total_closed = len(closed_trades)
            if total_closed > 0:
                # ç»Ÿè®¡ä¿¡æ¯
                total_profit = closed_trades["profit"].sum()  # æ‰€æœ‰äº¤æ˜“æ€»ç›ˆåˆ©
                win_trades = len(closed_trades[closed_trades["profit"] > 0])
                win_rate = win_trades / total_closed
                avg_profit = closed_trades["profit"].mean()

                final_equity = equity
                total_return_pct = (final_equity - self.initial_capital) / self.initial_capital

                print(f"\nğŸ“Š å›æµ‹ç»“æœ: {total_closed} ç¬”å¹³ä»“äº¤æ˜“")
                print(f"æ€»ç›ˆåˆ©: {total_profit:.2f}")
                print(f"èƒœç‡: {win_rate:.2%}")
                print(f"å¹³å‡å•ç¬”ç›ˆäº: {avg_profit:.4f}")
                print(f"æœ€ç»ˆèµ„é‡‘: {final_equity:.2f}")
                print(f"æ€»æ”¶ç›Šç‡: {total_return_pct:.2%}")
            else:
                print("\nâš ï¸ æ— å¹³ä»“äº¤æ˜“ï¼Œæ— æ³•ç»Ÿè®¡èƒœç‡å’Œæ”¶ç›Šç‡ã€‚")
        else:
            print("\nâš ï¸ æ— ä»»ä½•äº¤æ˜“è®°å½•ã€‚")

        return report


# ==================== ä½¿ç”¨ç¤ºä¾‹ ====================
if __name__ == "__main__":
    # 1) è·å–æ•°æ®
    fetcher = OKXDataFetcher(instId="TRUMP-USDT")
    fetcher.fetch_1m_data(days=1)  # ä¾‹å¦‚æ‹‰å–è¿‡å»1å¤©çš„1åˆ†é’Ÿæ•°æ®

    # 2) æ•´ç†æ•°æ®
    clean_data = fetcher.get_cleaned_data()

    # 3) åˆå§‹åŒ–å¹¶æ‰§è¡Œç­–ç•¥
    if clean_data is not None and not clean_data.empty:
        strategy = VolatilityMeanStrategy(
            data_df=clean_data,
            initial_capital=10000,
            params={
                "volatility_threshold": 0.005,
                "take_profit_long": 0.003,
                "stop_loss_long": 0.005,
                "take_profit_short": 0.003,
                "stop_loss_short": 0.005,
                "risk_per_trade": 0.02
            }
        )
        strategy.generate_signals()
        results = strategy.run_backtest()

        if results is not None and not results.empty:
            print("\n===== äº¤æ˜“æ˜ç»† =====")
            print(results[["entry_time", "type", "entry_price", "exit_price", "profit"]])
    else:
        print("âŒ æœªè·å–åˆ°æœ‰æ•ˆKçº¿æ•°æ®ï¼Œæ— æ³•è¿è¡Œç­–ç•¥ã€‚")
